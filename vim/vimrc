"" Personal vimrc
"" Author : 
"" Kim SangHoon <lucidash@gmail.com>
"" =========================================================

syntax on
scriptencoding utf-8
set nocompatible

set noswapfile
set nobackup

set visualbell
set history=1000
set undolevels=1000
set lazyredraw              " no redrawing during macro execution

" when launching files via quickfix, FZF, or something else,
" first switch to existing tab (if any) that contains the target buffer,
" or open a new buffer by splitting window in the current tab otherwise.
set switchbuf+=usetab,split

" diff: ignore whitespaces
set diffopt+=iwhite

" All the vim plugins, powered by 'vim-plug', are
" listed up in the separate file 'plugins.vim'.
" It is for making this vimrc could also work out-of-box
" even if not managed by dotfiles.
if filereadable(expand("\~/.vim/plugins.vim"))
  source \~/.vim/plugins.vim
endif

if filereadable('/bin/zsh')
  set shell=/bin/zsh
endif

" use path '~/.vim' even on non-unix machine
set runtimepath+=~/.vim


"" {{{{{{{{{{{
"" Arrow No map
map <leader>src :source ~/.vimrc<CR>
map <Up> <silent>
map <Down> <silent>
map <Left> <silent>
map <Right> <silent>
"" }}}}}}}}}}}
"" Arrow No map

nnoremap j gj
nnoremap k gk

" Easier to indent with < and > keys.
" do not exit from visual mode when shifting
vnoremap < <gv
vnoremap > >gv

" mouse behaviour
if has('mouse')
    set mouse=nvc
endif
if ! has('nvim')
    " vim only (not in neovim)
    set ttymouse=xterm2
endif


" ---------------------------------------------------------------- }}}
" FZF {{{

" Inside vim, set environment variable FZF_DEFAULT_COMMAND
" so that it can list the files by 'git ls-files' or 'ag'.
if executable("ag")
    "let $FZF_DEFAULT_COMMAND = '(git ls-files ":/" || ag -l -g "") | LC_COLLATE=C sort | uniq  2> /dev/null'
    let $FZF_DEFAULT_COMMAND = 'ag -l -g "" 2> /dev/null'
endif

" :F is a shortcut for :GFiles or :FZF
function! s:fzf_smart()
    let l:git_dir = fugitive#extract_git_dir(expand('%:p'))
    " in a git repo, invoke :GFiles (plus untracked files)
    if ! empty(l:git_dir) | GFiles -c -o --exclude-standard
    " not in git repo, invoke :FZF by fallback
    else | FZF
    endif
endfunction
command! -nargs=0 F call s:fzf_smart()

" Invoke F (FZF) Using Ctrl-P
nmap <C-P> :F<CR>


" custom commands using fzf

" :Z -- cd to recent working directories using fasd
command! -nargs=* Z call fzf#run
            \({
            \ 'source':  printf('fasd -Rdl "%s"',
            \                   escape(empty(<q-args>) ? '' : <q-args>, '"\')),
            \ 'options': '-1 -0 --no-sort +m',
            \ 'down':    '~33%',
            \ 'sink':    'NERDTree'
            \})

" :Plugs -- list all vim plugins and open the directory of the selected
command! -nargs=* Plugs call fzf#run
            \({
            \ 'source':  map(sort(keys(g:plugs)), 'g:plug_home . "/" . v:val'),
            \ 'options': '--delimiter "/" --nth -1' . printf(' --query "%s"', <q-args>),
            \ 'down':    '~33%',
            \ 'sink':    'NERDTree'
            \})

" Leader key mappings for vim-fzf commands


" buffer nav {{{{{
"map <s-w> <ESC>:bp <bar> sp <bar> bn <bar> bd <CR>
"map <c-l> :bn<CR>
"map <c-h> :bN<CR>
" }}}}}}}}


set mouse+=a
if &term =~ '^screen'
  "tmux knows the extended mouse mode
  set ttymouse=xterm2
endif

" EDITOR {{{ -----------------------------------------------
set nu ru sc wrap ls=2 lz                " -- appearance
set et bs=2 ts=2 sw=2 sts=2            " -- tabstop
set noai nosi hls is ic cf ws scs magic  " -- search
set sol sel=inclusive mps+=<:>           " -- moving around
set ut=10 uc=200                         " -- swap control
set report=0 lpl wmnu                    " -- misc.
set mouse=a

set list
set listchars=tab:»\ ,trail:·,extends:>,precedes:<

" encoding and file format
set fenc=utf-8 ff=unix ffs=unix,dos,mac
set fencs=utf-8,cp949,cp932,euc-jp,shift-jis,big5,latin2,ucs2-le

" list mode
"set nolist lcs=extends:>,precedes:<
"if &tenc ==? "utf-8"
"set lcs+=tab:»\ ,trail:·
"else
"set lcs+=tab:\|\ 
"endif
" }}} ------------------------------------------------------
"colorscheme desert256
colorscheme xoria256

nnoremap <CR> :noh<CR>
"" }}}}}}}}}}

set wildignore+=*/tmp/*,*.so,*.swp,*.zip

scripte utf-8
"set nocp all&

" TERMINAL {{{ ---------------------------------------------
if &term =~ "xterm"
  set t_Co=256
  if has("terminfo")
    let &t_Sf = "\<Esc>[3%p1%dm"
    let &t_Sb = "\<Esc>[4%p1%dm"
  else
    let &t_Sf = "\<Esc>[3%dm"
    let &t_Sb = "\<Esc>[4%dm"
  endif
endif


" terminal encoding (always use utf-8 if possible)
if !has("win32") || has("gui_running")
  set enc=utf-8 tenc=utf-8
  if has("win32")
    set tenc=cp949
    let $LANG = substitute($LANG, '\(\.[^.]\+\)\?$', '.utf-8', '')
  endif
endif

if &enc ==? "euc-kr"
  set enc=cp949
endif
" }}} ------------------------------------------------------
"




" TEMPORARY/BACKUP DIRECTORY {{{ ---------------------------
set swf nobk bex=.bak
if exists("$HOME")
  " makes various files written into ~/.vim/ or ~/_vim/
  let s:home_dir = substitute($HOME, '[/\\]$', '', '')
  if has("win32")
    let s:home_dir = s:home_dir . '/_vim'
  else
    let s:home_dir = s:home_dir . '/.vim'
  endif
  if isdirectory(s:home_dir)
    let &dir = s:home_dir . '/tmp,' . &dir
    let &bdir = s:home_dir . '/backup,' . &bdir
    let &vi = &vi . ',n' . s:home_dir . '/viminfo'
  endif
endif
" }}} ------------------------------------------------------


" immediate buffer configuration
"map <silent> <Leader>n :let &nu = 1 - &nu<CR>
"map <silent> <Leader>l :let &list = 1 - &list<CR>
"map <silent> <Leader>p :let &paste = 1 - &paste<CR>
"map <silent> <Leader>w :let &wrap = 1 - &wrap<CR>
"nmap <silent> <Leader>4 :set ts=4 sw=4<CR>
"nmap <silent> <Leader>8 :set ts=8 sw=8<CR>

" editing and applying .vimrc
if has("win32")
  nmap <silent> <Leader>R :so $HOME/_vimrc<CR>
  nmap <silent> <Leader>rc :ek$HOME/_vimrc<CR>
else
  nmap <silent> <Leader>R :so $HOME/.vimrc<CR>
  nmap <silent> <Leader>rc :e $HOME/.vimrc<CR>
endif

" inserting matching quotes
fu! s:InputQuotes()
  if mode() == "R"
    exe "normal \<Esc>" | return ""   " -- beep
  elseif match(getline("."), '\%u2018\%'.col('.').'c\%u2019') < 0
    return "\u2018\u2019\<Insert>\<BS>\<Insert>"
  else
    return "\<Del>\<BS>\u201c\u201d\<Insert>\<BS>\<Insert>"
  endif
endf
imap <silent> <C-'> <C-R>=<SID>InputQuotes()<CR>

" misc. mapping
nmap <silent> <Leader>cd :cd %:p:h<CR>
nmap <silent> <Leader><Space> :noh<CR>
" }}} ------------------------------------------------------


" SYNTAX {{{ -----------------------------------------------
syn enable
syn sync maxlines=1000
filet plugin indent on
let php_sync_method = 0
let html_wrong_comments = 1
" }}} ------------------------------------------------------

" AUTOCMD {{{ ----------------------------------------------
if has("autocmd")
  aug vimrc
    au!

    " filetype-specific configurations
    au FileType python setl ts=4 sw=4 sts=4 et
    au FileType html setl ts=4 sw=4 sts=4 et
    au FileType php setl ts=4 sw=4 sts=4 et
    au FileType cpp setl ts=4 sw=4 sts=4 noet
    au FileType c setl ts=4 sw=4 sts=4 noet
    au Filetype text setl tw=80
    au FileType javascript,jsp setl cin
    au FileType ruby setl ts=2 sw=2 sts=0 tw=0 et
    au BufNewFile,BufRead *.phps,*.php3s setf php

    """""""""""""" frientrip convention
    au FileType html set sw=2 et
    au FileType javascript set sw=2 et
    au FileType coffee set sw=2 et
    """""""""""""" frientrip convention

    " restore cursor position when the file has been read
    au BufReadPost *
          \ if line("'\"") > 0 && line("'\"") <= line("$") |
          \   exe "norm g`\"" |
          \ endif

    " fix window position for mac os x
    if has("gui_running") && has("macunix")
      au GUIEnter *
            \ if getwinposx() < 50 |
            \   exe ':winp 50 ' . (getwinposy() + 22) |
            \ endif
    endif

    " fix window size if window size has been changed
    if has("gui_running")
      fu! s:ResizeWindows()
        let l:nwins = winnr("$") | let l:num = 1
        let l:curtop = 0 | let l:curleft = 0
        let l:lines = &lines - &cmdheight
        let l:prevlines = s:prevlines - &cmdheight
        let l:cmd = ""
        while l:num < l:nwins
          if l:curleft == 0
            let l:adjtop = l:curtop * l:lines / l:prevlines
            let l:curtop = l:curtop + winheight(l:num) + 1
            if l:curtop < l:lines
              let l:adjheight = l:curtop * l:lines / l:prevlines - l:adjtop - 1
              let l:cmd = l:cmd . l:num . "resize " . l:adjheight . "|"
            endif
          endif
          let l:adjleft = l:curleft * &columns / s:prevcolumns
          let l:curleft = l:curleft + winwidth(l:num) + 1
          if l:curleft < &columns
            let l:adjwidth = l:curleft * &columns / s:prevcolumns - l:adjleft - 1
            let l:cmd = l:cmd . "vert " . l:num . "resize " . l:adjwidth . "|"
          else
            let l:curleft = 0
          endif
          let l:num = l:num + 1
        endw
        exe l:cmd
      endf
      fu! s:ResizeAllWindows()
        if v:version >= 700
          let l:tabnum = tabpagenr()
          tabdo call s:ResizeWindows()
          exe "norm " . l:tabnum . "gt"
        else
          call s:ResizeWindows()
        endif
        let s:prevlines = &lines | let s:prevcolumns = &columns
      endf
      au GUIEnter * let s:prevlines = &lines | let s:prevcolumns = &columns
      au VimResized * call s:ResizeAllWindows()
    endif

  aug END
endif
" }}} ------------------------------------------------------



" ----- Key mappings 
"
"
"the leader key
let mapleader=","           " comma is the <Leader> key.
let maplocalleader=","      " comma : <LocalLeader>

" comma is the <Leader> key now.

map <C-_> <leader>ci
map <C-=> :rewind<CR>G

" Switch between window splits using big J or K and expand the split to its 
" " full size. 
" " Move vertically in the window through the horizontal splits... 
nnoremap <C-J> <C-w>j
nnoremap <C-K> <C-w>k
" " Move horizontally in the window through the vertical splits... 
"nnoremap <C-H> <C-w>h
"nnoremap <C-L> <C-w>l

" Tab navigations
nnoremap <C-n>     :tabnew<CR>
nnoremap <C-S-tab> :tabprevious<CR>
nnoremap <C-tab>   :tabnext<CR>
nnoremap [t  :tabprevious<CR>
nnoremap ]t  :tabnext<CR>
map <leader>1 1gt
map <leader>2 2gt
map <leader>3 3gt
map <leader>4 4gt
map <leader>5 5gt
map <leader>6 6gt
map <leader>7 7gt
map <leader>8 8gt
map <leader>9 9gt
map <leader>0 :tablast<CR>

" Locations
nnoremap [l :lprevious<CR>
nnoremap ]l :lnext<CR>

" Plugin ag.vim
" <leader>ag (or rg): Ag (search file contents)
nnoremap <leader>ag :Ag! -i ""<Left>
xnoremap <silent> <leader>ag y:Ag <C-R>"<CR>
nnoremap <leader>rg :Ag! -i ""<Left>
xnoremap <silent> <leader>rg y:Ag <C-R>"<CR>


hi! Normal ctermbg=NONE guibg=NONE
hi! NonText ctermbg=NONE guibg=NONE


"" tabline plugin settings 
"" {{{{{
hi TabLine      ctermfg=Black  ctermbg=Gray     cterm=NONE
hi TabLineFill  ctermfg=Black  ctermbg=Gray     cterm=NONE
hi TabLineSel   ctermfg=White  ctermbg=DarkBlue  cterm=NONE
"" }}}}}


highlight Pmenu ctermfg=black ctermbg=yellow
highlight PmenuSel ctermfg=red ctermbg=white gui=bold

"" {{{{{{{{{{
"" ----- You Complte Me -------
""
""

autocmd FileType php set omnifunc=phpcomplete#CompletePHP


let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py' 
let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_use_ultisnips_completer = 1
let g:ycm_enable_diagnostic_signs = 0
let g:ycm_python_binary_path = 'python'
""
""
"" ----- You Complte Me -------
"" }}}}}}}}}}



"" {{{{{{{{{{
"" ----- jedi -------
"let g:jedi#popup_select_first = 0
"let g:jedi#popup_on_dot = 1
"" ----- jedi -------
"" }}}}}}}}}}

"" {{{{{{{{{{
"" ----- SnipMate -------
""
""
let g:UltiSnipsExpandTrigger="<c-j>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-k>"
""
""
"" ----- SnipMate -------
"" }}}}}}}}}}



"" {{{{{{{{{{
"" ----- Vim-bookmarks -------
let g:bookmark_save_per_working_dir = 1
let g:bookmark_auto_save = 1
let g:bookmark_auto_close = 1	
highlight BookmarkLine ctermbg=194 ctermfg=NONE
"let g:bookmark_highlight_lines = 1
let g:bookmark_center = 1
"" ----- Vim-bookmarks -------
"" }}}}}}}}}}


"" {{{{{{{{{{
"" ----- Gundo Toggle -------
nnoremap <F6> :GundoToggle<CR>
"" ----- Gundo Toggle -------
"" }}}}}}}}}}

"" {{{{{{{{{{
"" ----- CtrlP -------
let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)|node_modules|venv$'
"" ----- CtrlP -------
"" }}}}}}}}}}

"" {{{{{{{{{{
"" ----- Tagbar  -------
nnoremap <leader>t :TagbarToggle<CR>
"" ----- Tagbar  -------
"" }}}}}}}}}}

" ---------------------------------------------------------------- }}}
" vim-asterisk (enhanced *) {{{

"' Use z (stay) behavior as default
map *  <Plug>(asterisk-z*)
map #  <Plug>(asterisk-z#)
map g* <Plug>(asterisk-gz*)
map g# <Plug>(asterisk-gz#)

" Keep cursor position across matches
let g:asterisk#keeppos = 1

" ---------------------------------------------------------------- }}}
" incsearch {{{
" incsearch.vim
if has_key(g:plugs, 'incsearch.vim')
  map /  <Plug>(incsearch-forward)
  map ?  <Plug>(incsearch-backward)
  map g/ <Plug>(incsearch-stay)
endif

" incsearch-fuzzy.vim
map z/ <Plug>(incsearch-fuzzy-/)
map z? <Plug>(incsearch-fuzzy-?)
map zg/ <Plug>(incsearch-fuzzy-stay)

" ---------------------------------------------------------------- }}}
" vim-highlightedundo {{{

if has_key(g:plugs, 'vim-highlightedundo')
  nmap u     <Plug>(highlightedundo-undo)
  nmap <C-r> <Plug>(highlightedundo-redo)
  nmap U     <Plug>(highlightedundo-Undo)
  nmap g-    <Plug>(highlightedundo-gminus)
  nmap g+    <Plug>(highlightedundo-gplus)

  let g:highlightedundo#highlight_duration_delete = 500
  let g:highlightedundo#highlight_duration_add = 700
endif


"" -- Dummy Sign for SignColumn to be shown always 
"" {{{{{{{{{{{
autocmd BufEnter * sign define dummy 
autocmd BufEnter * execute 'sign place 9999 line=1 name=dummy buffer=' . bufnr('')
"" }}}}}}}}}}

"" -- Nerdtree settings 
"" {{{{{{{{{{{
let g:nerdtree_tabs_focus_on_files = 1
let g:nerdtree_tabs_open_on_console_startup=1
"" }}}}}}}}}}


"" IndentGuides
"" {{{{{{{{{{{
let g:indent_guides_enable_on_vim_startup = 0
let g:indent_guides_auto_colors = 0
hi IndentGuidesOdd  ctermbg=black
hi IndentGuidesEven ctermbg=darkgrey
"" }}}}}}}}}}


" ---------------------------------------------------------------- }}}
" Airline {{{
" Note: for airline theme, see the 'appearance' section

" use airline, with powerline-ish theme
let g:airline_powerline_fonts=1

" enable tabline feature
let g:airline#extensions#tabline#enabled = 1

" Display buffers (like tabs) in the tabline
" if there is only one tab
let g:airline#extensions#tabline#show_buffers = 1

" suppress mixed-indent warning for javadoc-like comments (/** */)
let g:airline#extensions#whitespace#mixed_indent_algo = 1


autocmd FileType c,cpp,java,javascript,html,ruby,python,pandoc
    \ autocmd BufWritePre <buffer> :call StripTrailingWhitespaces()

filetype plugin on
filetype indent on

au FileType ruby map <F5> <ESC>:w<CR>:!ruby %<CR>
au FileType python map <F5> <ESC>:w<CR>:!source %:h/.venv/bin/activate; python %<CR>
au FileType cpp map <F4> <ESC>:w<CR>:!g++ -O2 -std=gnu++11 % && ./a.out 
au FileType cpp map <F5> <ESC>:w<CR>:!g++ -O2 -std=gnu++11 % && ./a.out < in <CR>
au FileType c map <F5> <ESC>:w<CR>:!gcc %<CR><CR>:!./a.out < input.txt<CR>
au FileType ruby map <leader>! <ESC>:w<CR>:!ruby %<CR>
au FileType python map <leader>! <ESC>:w<CR>:!source %:h/.venv/bin/activate; python %<CR>
au FileType python map <leader>@ <ESC>:w<CR>:!source %:h/.venv/bin/activate; python % < in<CR>
au FileType cpp map <leader>! <ESC>:w<CR>:!g++ -O2 -std=gnu++11 % && ./a.out<CR>
au FileType cpp map <leader>@ <ESC>:w<CR>:!g++ -O2 -std=gnu++11 % && ./a.out < in <CR>
imap <F2> <ESC>:w<CR>
map <F3> <ESC>:!cat %\|pbcopy<CR>


function! BufferDelete()
    if &modified
        echohl ErrorMsg
        echomsg "No write since last change. Not closing buffer."
        echohl NONE
    else
        let s:total_nr_buffers = len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))

        if s:total_nr_buffers == 1
            bdelete
            echo "Buffer deleted. Created new buffer."
        else
            bprevious
            bdelete #
            echo "Buffer deleted."
        endif
    endif
endfunction
